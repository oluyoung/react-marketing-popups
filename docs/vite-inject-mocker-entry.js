import{_ as W}from"./assets/preload-helper-PPVm8Dsz.js";class X{registryByUrl=new Map;registryById=new Map;clear(){this.registryByUrl.clear(),this.registryById.clear()}keys(){return this.registryByUrl.keys()}add(e){this.registryByUrl.set(e.url,e),this.registryById.set(e.id,e)}register(e,t,r,i,s){const a=typeof e=="object"?e.type:e;if(typeof e=="object"){const o=e;if(o instanceof _||o instanceof v||o instanceof E||o instanceof w)throw new TypeError(`[vitest] Cannot register a mock that is already defined. Expected a JSON representation from \`MockedModule.toJSON\`, instead got "${o.type}". Use "registry.add()" to update a mock instead.`);if(o.type==="automock"){const c=_.fromJSON(o);return this.add(c),c}else if(o.type==="autospy"){const c=v.fromJSON(o);return this.add(c),c}else if(o.type==="redirect"){const c=w.fromJSON(o);return this.add(c),c}else throw o.type==="manual"?new Error("Cannot set serialized manual mock. Define a factory function manually with `ManualMockedModule.fromJSON()`."):new Error(`Unknown mock type: ${o.type}`)}if(typeof t!="string")throw new TypeError("[vitest] Mocks require a raw string.");if(typeof i!="string")throw new TypeError("[vitest] Mocks require a url string.");if(typeof r!="string")throw new TypeError("[vitest] Mocks require an id string.");if(a==="manual"){if(typeof s!="function")throw new TypeError("[vitest] Manual mocks require a factory function.");const o=new E(t,r,i,s);return this.add(o),o}else if(a==="automock"||a==="autospy"){const o=a==="automock"?new _(t,r,i):new v(t,r,i);return this.add(o),o}else if(a==="redirect"){if(typeof s!="string")throw new TypeError("[vitest] Redirect mocks require a redirect string.");const o=new w(t,r,i,s);return this.add(o),o}else throw new Error(`[vitest] Unknown mock type: ${a}`)}delete(e){this.registryByUrl.delete(e)}get(e){return this.registryByUrl.get(e)}getById(e){return this.registryById.get(e)}has(e){return this.registryByUrl.has(e)}}class _{type="automock";constructor(e,t,r){this.raw=e,this.id=t,this.url=r}static fromJSON(e){return new v(e.raw,e.id,e.url)}toJSON(){return{type:this.type,url:this.url,raw:this.raw,id:this.id}}}class v{type="autospy";constructor(e,t,r){this.raw=e,this.id=t,this.url=r}static fromJSON(e){return new v(e.raw,e.id,e.url)}toJSON(){return{type:this.type,url:this.url,id:this.id,raw:this.raw}}}class w{type="redirect";constructor(e,t,r,i){this.raw=e,this.id=t,this.url=r,this.redirect=i}static fromJSON(e){return new w(e.raw,e.id,e.url,e.redirect)}toJSON(){return{type:this.type,url:this.url,raw:this.raw,id:this.id,redirect:this.redirect}}}class E{cache;type="manual";constructor(e,t,r,i){this.raw=e,this.id=t,this.url=r,this.factory=i}async resolve(){if(this.cache)return this.cache;let e;try{e=await this.factory()}catch(t){const r=new Error('[vitest] There was an error when mocking a module. If you are using "vi.mock" factory, make sure there are no top level variables inside, since this call is hoisted to top of the file. Read more: https://vitest.dev/api/vi.html#vi-mock');throw r.cause=t,r}if(e===null||typeof e!="object"||Array.isArray(e))throw new TypeError(`[vitest] vi.mock("${this.raw}", factory?: () => unknown) is not returning an object. Did you mean to return an object with a "default" key?`);return this.cache=e}static fromJSON(e,t){return new E(e.raw,e.id,e.url,t)}toJSON(){return{type:this.type,url:this.url,id:this.id,raw:this.raw}}}function j(n,e,t={}){const r=new Array,i=new Y,s=(c,l,u)=>{try{return c[l]=u,!0}catch{return!1}},a=(c,l)=>{const u=x(c),h=u==="Module"||!!c.__esModule;for(const{key:f,descriptor:p}of O(c,h,n.globalConstructors)){if(!h&&p.get){try{Object.defineProperty(l,f,p)}catch{}continue}if(K(f,u))continue;const d=c[f],$=i.getId(d);if($!==void 0){r.push(()=>s(l,f,i.getMockedValue($)));continue}const b=x(d);if(Array.isArray(d)){s(l,f,[]);continue}const I=b.includes("Function")&&typeof d=="function";if((!I||d._isMockFunction)&&b!=="Object"&&b!=="Module"){s(l,f,d);continue}if(s(l,f,I?d:{})){if(I){let M=function(){if(this instanceof l[f])for(const{key:k,descriptor:z}of O(this,!1,n.globalConstructors)){if(z.get)continue;const R=this[k];if(x(R).includes("Function")&&typeof R=="function"){const A=this[k],y=P(this,k).mockImplementation(A),V=y.mockReset;y.mockRestore=y.mockReset=()=>(V.call(y),y.mockImplementation(A),y)}}};if(!n.spyOn)throw new Error("[@vitest/mocker] `spyOn` is not defined. This is a Vitest error. Please open a new issue with reproduction.");const P=n.spyOn,m=P(l,f);if(n.type==="automock"){m.mockImplementation(M);const k=m.mockReset;m.mockRestore=m.mockReset=()=>(k.call(m),m.mockImplementation(M),m)}Object.defineProperty(l[f],"length",{value:0})}i.track(d,l[f]),a(d,l[f])}}},o=t;a(e,o);for(const c of r)c();return o}class Y{idMap=new Map;mockedValueMap=new Map;getId(e){return this.idMap.get(e)}getMockedValue(e){return this.mockedValueMap.get(e)}track(e,t){const r=this.idMap.size;return this.idMap.set(e,r),this.mockedValueMap.set(r,t),r}}function x(n){return Object.prototype.toString.apply(n).slice(8,-1)}function K(n,e){return e.includes("Function")&&typeof n=="string"&&["arguments","callee","caller","length","name"].includes(n)}function O(n,e,t){const{Map:r,Object:i,Function:s,RegExp:a,Array:o}=t,c=new r;let l=n;do{if(l===i.prototype||l===s.prototype||l===a.prototype)break;H(l,u=>{const h=i.getOwnPropertyDescriptor(l,u);h&&c.set(u,{key:u,descriptor:h})})}while(l=i.getPrototypeOf(l));if(e&&!c.has("default")&&"default"in n){const u=i.getOwnPropertyDescriptor(n,"default");u&&c.set("default",{key:"default",descriptor:u})}return o.from(c.values())}function H(n,e){const t=typeof e=="function"?e:r=>e.add(r);Object.getOwnPropertyNames(n).forEach(t),Object.getOwnPropertySymbols(n).forEach(t)}const Z=/^[A-Za-z]:\//;function q(n=""){return n&&n.replace(/\\/g,"/").replace(Z,e=>e.toUpperCase())}const G=/^[/\\]{2}/,Q=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/,ee=/^[A-Za-z]:$/,te=/.(\.[^./]+|\.)$/,re=function(n){if(n.length===0)return".";n=q(n);const e=n.match(G),t=C(n),r=n[n.length-1]==="/";return n=ie(n,!t),n.length===0?t?"/":r?"./":".":(r&&(n+="/"),ee.test(n)&&(n+="/"),e?t?`//${n}`:`//./${n}`:t&&!C(n)?`/${n}`:n)},ne=function(...n){let e="";for(const t of n)if(t)if(e.length>0){const r=e[e.length-1]==="/",i=t[0]==="/";r&&i?e+=t.slice(1):e+=r||i?t:`/${t}`}else e+=t;return re(e)};function ie(n,e){let t="",r=0,i=-1,s=0,a=null;for(let o=0;o<=n.length;++o){if(o<n.length)a=n[o];else{if(a==="/")break;a="/"}if(a==="/"){if(!(i===o-1||s===1))if(s===2){if(t.length<2||r!==2||t[t.length-1]!=="."||t[t.length-2]!=="."){if(t.length>2){const c=t.lastIndexOf("/");c===-1?(t="",r=0):(t=t.slice(0,c),r=t.length-1-t.lastIndexOf("/")),i=o,s=0;continue}else if(t.length>0){t="",r=0,i=o,s=0;continue}}e&&(t+=t.length>0?"/..":"..",r=2)}else t.length>0?t+=`/${n.slice(i+1,o)}`:t=n.slice(i+1,o),r=o-i-1;i=o,s=0}else a==="."&&s!==-1?++s:s=-1}return t}const C=function(n){return Q.test(n)},oe=function(n){if(n==="..")return"";const e=te.exec(q(n));return e&&e[1]||""};function F(n){return String(n)}F.open="";F.close="";let se=()=>"Promise{â€¦}";try{const{getPromiseDetails:n,kPending:e,kRejected:t}=process.binding("util");Array.isArray(n(Promise.resolve()))&&(se=(r,i)=>{const[s,a]=n(r);return s===e?"Promise{<pending>}":`Promise${s===t?"!":""}{${i.inspect(a,i)}}`})}catch{}function ce(n){const{message:e="$$stack trace error",stackTraceLimit:t=1}=n||{},r=Error.stackTraceLimit,i=Error.prepareStackTrace;Error.stackTraceLimit=t,Error.prepareStackTrace=o=>o.stack;const a=new Error(e).stack||"";return Error.prepareStackTrace=i,Error.stackTraceLimit=r,a}const N="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",ae=new Uint8Array(64),le=new Uint8Array(128);for(let n=0;n<N.length;n++){const e=N.charCodeAt(n);ae[n]=e,le[e]=n}var L;L||(L={});const ue=/^[A-Za-z]:\//;function fe(n=""){return n&&n.replace(/\\/g,"/").replace(ue,e=>e.toUpperCase())}const de=/^[/\\](?![/\\])|^[/\\]{2}(?!\.)|^[A-Za-z]:[/\\]/;function pe(){return typeof process<"u"&&typeof process.cwd=="function"?process.cwd().replace(/\\/g,"/"):"/"}const he=function(...n){n=n.map(r=>fe(r));let e="",t=!1;for(let r=n.length-1;r>=-1&&!t;r--){const i=r>=0?n[r]:pe();!i||i.length===0||(e=`${i}/${e}`,t=J(i))}return e=me(e,!t),t&&!J(e)?`/${e}`:e.length>0?e:"."};function me(n,e){let t="",r=0,i=-1,s=0,a=null;for(let o=0;o<=n.length;++o){if(o<n.length)a=n[o];else{if(a==="/")break;a="/"}if(a==="/"){if(!(i===o-1||s===1))if(s===2){if(t.length<2||r!==2||t[t.length-1]!=="."||t[t.length-2]!=="."){if(t.length>2){const c=t.lastIndexOf("/");c===-1?(t="",r=0):(t=t.slice(0,c),r=t.length-1-t.lastIndexOf("/")),i=o,s=0;continue}else if(t.length>0){t="",r=0,i=o,s=0;continue}}e&&(t+=t.length>0?"/..":"..",r=2)}else t.length>0?t+=`/${n.slice(i+1,o)}`:t=n.slice(i+1,o),r=o-i-1;i=o,s=0}else a==="."&&s!==-1?++s:s=-1}return t}const J=function(n){return de.test(n)},D=/^\s*at .*(?:\S:\d+|\(native\))/m,ye=/^(?:eval@)?(?:\[native code\])?$/;function U(n){if(!n.includes(":"))return[n];const t=/(.+?)(?::(\d+))?(?::(\d+))?$/.exec(n.replace(/^\(|\)$/g,""));if(!t)return[n];let r=t[1];if(r.startsWith("async ")&&(r=r.slice(6)),r.startsWith("http:")||r.startsWith("https:")){const i=new URL(r);i.searchParams.delete("import"),i.searchParams.delete("browserv"),r=i.pathname+i.hash+i.search}if(r.startsWith("/@fs/")){const i=/^\/@fs\/[a-zA-Z]:\//.test(r);r=r.slice(i?5:4)}return[r,t[2]||void 0,t[3]||void 0]}function ge(n){let e=n.trim();if(ye.test(e)||(e.includes(" > eval")&&(e=e.replace(/ line (\d+)(?: > eval line \d+)* > eval:\d+:\d+/g,":$1")),!e.includes("@")&&!e.includes(":")))return null;const t=/((.*".+"[^@]*)?[^@]*)(@)/,r=e.match(t),i=r&&r[1]?r[1]:void 0,[s,a,o]=U(e.replace(t,""));return!s||!a||!o?null:{file:s,method:i||"",line:Number.parseInt(a),column:Number.parseInt(o)}}function ve(n){const e=n.trim();return D.test(e)?we(e):ge(e)}function we(n){let e=n.trim();if(!D.test(e))return null;e.includes("(eval ")&&(e=e.replace(/eval code/g,"eval").replace(/(\(eval at [^()]*)|(,.*$)/g,""));let t=e.replace(/^\s+/,"").replace(/\(eval code/g,"(").replace(/^.*?\s+/,"");const r=t.match(/ (\(.+\)$)/);t=r?t.replace(r[0],""):t;const[i,s,a]=U(r?r[1]:t);let o=r&&t||"",c=i&&["eval","<anonymous>"].includes(i)?void 0:i;return!c||!s||!a?null:(o.startsWith("async ")&&(o=o.slice(6)),c.startsWith("file://")&&(c=c.slice(7)),c=c.startsWith("node:")||c.startsWith("internal:")?c:he(c),o&&(o=o.replace(/__vite_ssr_import_\d+__\./g,"")),{method:o,file:c,line:Number.parseInt(s),column:Number.parseInt(a)})}function ke(n){const e=n?.globalThisKey||"__vitest_mocker__";function t(){return typeof globalThis[e]<"u"?globalThis[e]:new Proxy({},{get(r,i){throw new Error(`Vitest mocker was not initialized in this environment. vi.${String(i)}() is forbidden.`)}})}return{hoisted(r){if(typeof r!="function")throw new TypeError(`vi.hoisted() expects a function, but received a ${typeof r}`);return r()},mock(r,i){if(typeof r!="string")throw new TypeError(`vi.mock() expects a string path, but received a ${typeof r}`);const s=g("mock");t().queueMock(r,s,typeof i=="function"?()=>i(()=>t().importActual(r,s)):i)},unmock(r){if(typeof r!="string")throw new TypeError(`vi.unmock() expects a string path, but received a ${typeof r}`);t().queueUnmock(r,g("unmock"))},doMock(r,i){if(typeof r!="string")throw new TypeError(`vi.doMock() expects a string path, but received a ${typeof r}`);const s=g("doMock");t().queueMock(r,s,typeof i=="function"?()=>i(()=>t().importActual(r,s)):i)},doUnmock(r){if(typeof r!="string")throw new TypeError(`vi.doUnmock() expects a string path, but received a ${typeof r}`);t().queueUnmock(r,g("doUnmock"))},async importActual(r){return t().importActual(r,g("importActual"))},async importMock(r){return t().importMock(r,g("importMock"))}}}function g(n){const t=ce({stackTraceLimit:5}).split(`
`),r=t.findIndex(s=>s.includes(` at Object.${n}`)||s.includes(`${n}@`)),i=ve(t[r+1]);return i?.file||""}const{now:B}=Date;class Se{registry=new X;queue=new Set;mockedIds=new Set;constructor(e,t,r,i){this.interceptor=e,this.rpc=t,this.spyOn=r,this.config=i}async prepare(){this.queue.size&&await Promise.all([...this.queue.values()])}async resolveFactoryModule(e){const t=this.registry.get(e);if(!t||t.type!=="manual")throw new Error(`Mock ${e} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);return await t.resolve()}getFactoryModule(e){const t=this.registry.get(e);if(!t||t.type!=="manual")throw new Error(`Mock ${e} wasn't registered. This is probably a Vitest error. Please, open a new issue with reproduction.`);if(!t.cache)throw new Error(`Mock ${e} wasn't resolved. This is probably a Vitest error. Please, open a new issue with reproduction.`);return t.cache}async invalidate(){const e=Array.from(this.mockedIds);e.length&&(await this.rpc.invalidate(e),await this.interceptor.invalidate(),this.registry.clear())}async importActual(e,t){const r=await this.rpc.resolveId(e,t);if(r==null)throw new Error(`[vitest] Cannot resolve "${e}" imported from "${t}"`);const i=oe(r.id),s=new URL(r.url,location.href),a=`_vitest_original&ext${i}`,o=`${s.pathname}${s.search?`${s.search}&${a}`:`?${a}`}${s.hash}`;return this.wrapDynamicImport(()=>import(o)).then(c=>{if(!r.optimized||typeof c.default>"u")return c;const l=c.default;return l?.__esModule?l:{...typeof l=="object"&&!Array.isArray(l)||typeof l=="function"?l:{},default:l}})}async importMock(e,t){await this.prepare();const{resolvedId:r,resolvedUrl:i,redirectUrl:s}=await this.rpc.resolveMock(e,t,{mock:"auto"}),a=this.resolveMockPath(S(i));let o=this.registry.get(a);if(!o)if(s){const c=new URL(this.resolveMockPath(S(s)),location.href).toString();o=new w(e,r,a,c)}else o=new _(e,r,a);if(o.type==="manual")return await o.resolve();if(o.type==="automock"||o.type==="autospy"){const c=new URL(`/@id/${r}`,location.href),l=c.search?`${c.search}&t=${B()}`:`?t=${B()}`,u=await W(()=>import(`${c.pathname}${l}&mock=${o.type}${c.hash}`),[],import.meta.url);return this.mockObject(u,o.type)}return import(o.redirect)}mockObject(e,t="automock"){return j({globalConstructors:{Object,Function,Array,Map,RegExp},spyOn:this.spyOn,type:t},e)}queueMock(e,t,r){const i=this.rpc.resolveMock(e,t,{mock:typeof r=="function"?"factory":r?.spy?"spy":"auto"}).then(async({redirectUrl:s,resolvedId:a,resolvedUrl:o,needsInterop:c,mockType:l})=>{const u=this.resolveMockPath(S(o));this.mockedIds.add(a);const h=typeof r=="function"?async()=>{const d=await r();return c?{default:d}:d}:void 0,f=typeof s=="string"?new URL(this.resolveMockPath(S(s)),location.href).toString():null;let p;l==="manual"?p=this.registry.register("manual",e,a,u,h):l==="autospy"?p=this.registry.register("autospy",e,a,u):l==="redirect"?p=this.registry.register("redirect",e,a,u,f):p=this.registry.register("automock",e,a,u),await this.interceptor.register(p)}).finally(()=>{this.queue.delete(i)});this.queue.add(i)}queueUnmock(e,t){const r=this.rpc.resolveId(e,t).then(async i=>{if(!i)return;const s=this.resolveMockPath(S(i.url));this.mockedIds.add(i.id),this.registry.delete(s),await this.interceptor.delete(s)}).finally(()=>{this.queue.delete(r)});this.queue.add(r)}wrapDynamicImport(e){return typeof e=="function"?new Promise((r,i)=>{this.prepare().finally(()=>{e().then(r,i)})}):e}resolveMockPath(e){const t=this.config,r=ne("/@fs/",t.root);return e.startsWith(t.root)?e.slice(t.root.length):e.startsWith(r)?e.slice(r.length):e}}const _e=/(\?|&)v=\w{8}/;function S(n){return n.replace(_e,"")}class Ee{mocks=new X;constructor(){}async register(e){this.mocks.add(e)}async delete(e){this.mocks.delete(e)}async invalidate(){this.mocks.clear()}}const T=n=>{switch(n){case"resolveId":return Promise.resolve({id:"",url:"",optimized:!1});case"resolveMock":return Promise.resolve({mockType:"dummy",resolvedId:"",resolvedUrl:"",redirectUrl:"",needsInterop:!1});case"invalidate":return Promise.resolve()}};class be extends Se{queueMock(){}}function Ie(n){const e=new be(n("__vitest_mocker__"),{resolveId(t,r){return T("resolveId")},resolveMock(t,r,i){return T("resolveMock")},async invalidate(t){return T("invalidate")}},(...t)=>globalThis.__STORYBOOK_MODULE_TEST__.spyOn(...t),{root:""});return globalThis.__vitest_mocker__=e,ke({globalThisKey:"__vitest_mocker__"})}globalThis.__STORYBOOK_MOCKER__=Ie(()=>new Ee);
